% Tallies T/N counting Toxicities per Number enrolled

:- module(tally, [
	      qcompare/4, % reified versions only should suffice
	      op(900, xfx, &=<),
	      (&=<)/3,
	      op(900, xfx, &>=),
	      (&>=)/3
	  ]).

:- use_module(library(clpz)).
:- use_module(library(pio)).
:- use_module(library(lists)).
:- use_module(library(dcgs)).
:- use_module(library(time)).
:- use_module(library(debug)).
:- use_module(library(dif)).
:- use_module(library(reif)).
:- use_module(library(format)).
:- use_module(library(lambda)).
:- use_module(inconceivable).

%% The most fundamental relation between tallies is REACHABILITY,
%% the question of whether a possible path exists connecting them.
qcompare(~~, T1/N1, T2/N2) :- % REACHABILITY
    %% The following conditions translate as follows, under 3 scenarios:
    %% (=) If N1==N2, then we get T2 =< T1 =< T2 which holds iff T1==T2.
    %% (<) If N1 < N2, these conds translate to T1 =< T2 =< T1 + MaxTox.
    %% (>) If N1 > N2, these conds translate to T2 =< T1 =< T2 + MaxTox.
    T2 #=< T1 + max(0, N2 - N1),
    T1 #=< T2 + max(0, N1 - N2).

/*

This ~~ relation naturally gives us EQUIVALENCE CLASSES that we
can use to define a PARTIAL ORDERING on tallies that extends the
natural ordering between 2 tallies sharing a common denominator.
Specifically, for any 2 tallies, Q1 = T1/N1 and Q2 = T2/N2 with
N1 < N2 (we call Q1 the 'earlier' tally and Q2 the 'later' one),
we can project the earlier tally forward in time to a reachable
of tallies {Tr/N2 | Tr/N2 ~~ T1/N1}, and then compare that set
(in the obvious way) to Q2. If every element of the set bears
some relation to Q2, then we can say Q1 bears that relation
modulo reachability.

A graphical analysis of this relation is helpful. Here are the
relations generated by the tally 3/5, on the simplex of tallies
depicted as a grid:

  7  >  >  >  >  >  >  >  >  >  ≥

  6  >  >  >  >  >  >  >  >  ≥

  5  >  >  >  >  >  >  >  ≥

  4  >  >  >  >  >  >  ≥

  3  ≥  ≥  ≥  ≥  ≥  =  ≤  ≤  ≤  ≤

  2              ≤  <  <  <  <  <

  1           ≤  <  <  <  <  <  <

  0        ≤  <  <  <  <  <  <  <
 T
     0  1  2  3  4  5  6  7  8  9
    N

Note that nonexistent tallies (T/N with T>N) are included in the
relation, in order to emphasize the geometry, especially in the
'northwest' part of the figure, where imposing T≯N would wipe out
the ramp function formed by the (≥). Note how an (=)
is of course generated at 3/5, and how paired rays of (≤) and (≥)
emanate from 3/5, defining boundaries with interiors where the
corresponding *strict* relations hold. Note also that there are
two acute angles where neither relation holds. Thus, for example,
we cannot assert any relation between 2/3 and 3/5, because the
tallies reachable from 2/3 span the range 2/5--4/5, bracketed by
2/5 < 3/5 < 4/5. (Indeed, the reachability relation does hold,
so we could write 2/3 ~~ 3/5. But, as will become clear below,
it is the inequalities (≤) and (≥) that will provide the motive
force driving dose-escalation decisions. So reachability ~~ is
not emphasized in this figure.)

The geometry of this figure---and especially the CONVEXITY of the
obtuse-angle regions bounded by (≤) and (≥)---aids in understanding
the implementation of the qcompare/3 clauses below, and appreciating
properties of these relations, such as their transitivity.

*/

%% Note that, for reasons of performance, we express these relations
%% in terms of CLP(ℤ) constraints rather than by directly generating
%% the reachable sets.
%% TODO: Nevertheless, Prolog-based PROOFS via such representations
%%       might well have intrinsic interest.
%% Note also that we implement these comparisons on all of ℕ × ℕ, so that
%% queries about tallies must assert the simplex constraint themselves.
qcompare(=<, T1/N1, T2/N2) :-
    #T1 + max(0, #N2 - #N1) #=< #T2.

qcompare(<, T1/N1, T2/N2) :-
    #T1 + max(0, #N2 - #N1) #< #T2.

qcompare(>=, T1/N1, T2/N2) :-
    #T1 #>= #T2 + max(0, #N1 - #N2).

qcompare(>, T1/N1, T2/N2) :-
    #T1 #> #T2 + max(0, #N1 - #N2).

%% Reified versions of the above, as done at bottom of clpz.pl
qcompare(=<, T1/N1, T2/N2, Truth) :-
    #T1 + max(0, #N2 - #N1) #=< #T2 #<==> B,
    zo_t(B, Truth).

qcompare(<, T1/N1, T2/N2, Truth) :-
    #T1 + max(0, #N2 - #N1) #< #T2 #<==> B,
    zo_t(B, Truth).
	
qcompare(>=, Q1, Q2, Truth) :- qcompare(=<, Q2, Q1, Truth).

qcompare(>, T1/N1, T2/N2, Truth) :-
    #T1 #> #T2 + max(0, #N1 - #N2) #<==> B,
    zo_t(B, Truth).

zo_t(0, false).
zo_t(1, true).

%% Operators for the truly useful comparisons of BOIN:
:- op(900, xfx, &=<).
&=<(Q1, Q2) :-
    qcompare(=<, Q1, Q2).

&=<(Q1, Q2, Truth) :- % reified
    qcompare(=<, Q1, Q2, Truth).

:- op(900, xfx, &>=).
&>=(Q1, Q2) :-
    qcompare(>=, Q1, Q2).

&>=(Q1, Q2, Truth) :- % reified
    qcompare(>=, Q1, Q2, Truth).


%% Fairly enumerate tally pairs (Q1, Q2) pairs JOINTLY to avoid
%% repeating tests while 'sweeping' the space of cases to exclude
%% the 'inconceivable' systematically on increasing subsets of
%% the domain.
%% This is intended to be invoked with (Size in Min..Max), as e.g.
%% by inconceivable/3.
tally_pair(T1/N1, T2/N2, Size) :-
    #Size #> 0,
    #N1 #= #Size, % NB: naive (N1 in 1..Size) would duplicate pairs
    N2 in 1..N1, indomain(N2),
    T1 in 0..N1,
    T2 in 0..N2,
    indomain(T1), indomain(T2).

%% TODO: Generalize tally_pair/3, tally_triple/4 to LISTS of tallies?
tally_triple(T1/N1, T2/N2, T3/N3, Size) :-
    tally_pair(T1/N1, T2/N2, Size),
    N3 in 1..N2, indomain(N3),
    T3 in 0..N3.

%% Demonstrate the TRANSITIVITY of (&=<) and (&>=)
violate_transitivity(C, Q1, Q2, Q3, Size) :-
    tally_triple(Q1, Q2, Q3, Size),
    qcompare(C, Q1, Q2),
    qcompare(C, Q2, Q3),
    %% At this point Q1 (C) Q2 (C) Q3 holds, and now we
    %% ask whether it's possible that Q1 (C) Q3 DOESN'T:
    qcompare(C, Q1, Q3, false). % reification to the rescue!

test :-
    (	format("Show that =< and >= hold simultaneously only in case of equivalence:~n", []),
	inconceivable((tally_pair(Q1, Q2, MaxN),
		       qcompare(>=, Q1, Q2),
		       qcompare(=<, Q1, Q2),
		       dif(Q1, Q2)),
		      MaxN, 1..12)
    ;	format("Demonstrate that strict inequalities are exclusive of ~~ ...~n", []),
	inconceivable((tally_pair(Q1, Q2, MaxN),
		       qcompare(>, Q1, Q2),
		       qcompare(~~, Q1, Q2)),
		      MaxN, 1..12)
    ;	inconceivable((tally_pair(Q1, Q2, MaxN),
		       qcompare(<, Q1, Q2),
		       qcompare(~~, Q1, Q2)),
		      MaxN, 1..12)
    ;	format("Show that =< and >= hold simultaneously only in case of equivalence:~n", []),
	inconceivable((tally_pair(Q1, Q2, MaxN),
		       qcompare(>=, Q1, Q2),
		       qcompare(=<, Q1, Q2),
		       dif(Q1, Q2)),
		      MaxN, 1..12)
    ;	format("Demonstrate transitivity of =< and >= ...~n", []),
	inconceivable(violate_transitivity(>=, Q1, Q2, Q3, Size), Size, 1..12)
    ;	inconceivable(violate_transitivity(=<, Q1, Q2, Q3, Size), Size, 1..12)
    ).

%?- tally:test.
%@ Show that =< and >= hold simultaneously only in case of equivalence:
%@  % A = 1 ...   % CPU time: 0.028 seconds
%@  % A = 2 ...   % CPU time: 0.071 seconds
%@  % A = 3 ...   % CPU time: 0.145 seconds
%@  % A = 4 ...   % CPU time: 0.231 seconds
%@  % A = 5 ...   % CPU time: 0.369 seconds
%@  % A = 6 ...   % CPU time: 0.556 seconds
%@  % A = 7 ...   % CPU time: 0.802 seconds
%@  % A = 8 ...   % CPU time: 1.125 seconds
%@  % A = 9 ...   % CPU time: 1.453 seconds
%@  % A = 10 ...   % CPU time: 1.911 seconds
%@  % A = 11 ...   % CPU time: 2.427 seconds
%@  % A = 12 ...   % CPU time: 3.027 seconds
%@ Demonstrate that strict inequalities are exclusive of ~ ...
%@  % A = 1 ...   % CPU time: 0.026 seconds
%@  % A = 2 ...   % CPU time: 0.063 seconds
%@  % A = 3 ...   % CPU time: 0.129 seconds
%@  % A = 4 ...   % CPU time: 0.228 seconds
%@  % A = 5 ...   % CPU time: 0.353 seconds
%@  % A = 6 ...   % CPU time: 0.553 seconds
%@  % A = 7 ...   % CPU time: 0.781 seconds
%@  % A = 8 ...   % CPU time: 1.096 seconds
%@  % A = 9 ...   % CPU time: 1.412 seconds
%@  % A = 10 ...   % CPU time: 1.860 seconds
%@  % A = 11 ...   % CPU time: 2.396 seconds
%@  % A = 12 ...   % CPU time: 2.988 seconds
%@  % A = 1 ...   % CPU time: 0.025 seconds
%@  % A = 2 ...   % CPU time: 0.066 seconds
%@  % A = 3 ...   % CPU time: 0.134 seconds
%@  % A = 4 ...   % CPU time: 0.224 seconds
%@  % A = 5 ...   % CPU time: 0.362 seconds
%@  % A = 6 ...   % CPU time: 0.544 seconds
%@  % A = 7 ...   % CPU time: 0.780 seconds
%@  % A = 8 ...   % CPU time: 1.078 seconds
%@  % A = 9 ...   % CPU time: 1.437 seconds
%@  % A = 10 ...   % CPU time: 1.876 seconds
%@  % A = 11 ...   % CPU time: 2.407 seconds
%@  % A = 12 ...   % CPU time: 3.008 seconds
%@ Show that =< and >= hold simultaneously only in case of equivalence:
%@  % A = 1 ...   % CPU time: 0.031 seconds
%@  % A = 2 ...   % CPU time: 0.069 seconds
%@  % A = 3 ...   % CPU time: 0.138 seconds
%@  % A = 4 ...   % CPU time: 0.233 seconds
%@  % A = 5 ...   % CPU time: 0.380 seconds
%@  % A = 6 ...   % CPU time: 0.565 seconds
%@  % A = 7 ...   % CPU time: 0.796 seconds
%@  % A = 8 ...   % CPU time: 1.087 seconds
%@  % A = 9 ...   % CPU time: 1.464 seconds
%@  % A = 10 ...   % CPU time: 1.897 seconds
%@  % A = 11 ...   % CPU time: 2.437 seconds
%@  % A = 12 ...   % CPU time: 3.009 seconds
%@ Demonstrate transitivity of =< and >= ...
%@  % A = 1 ...   % CPU time: 0.138 seconds
%@  % A = 2 ...   % CPU time: 0.612 seconds
%@  % A = 3 ...   % CPU time: 1.697 seconds
%@  % A = 4 ...   % CPU time: 3.906 seconds
%@  % A = 5 ...   % CPU time: 7.643 seconds
%@  % A = 6 ...   % CPU time: 13.768 seconds
%@  % A = 7 ...   % CPU time: 22.877 seconds
%@  % A = 8 ...   % CPU time: 36.325 seconds
%@  % A = 9 ...   % CPU time: 55.229 seconds
%@  % A = 10 ...   % CPU time: 83.390 seconds
%@  % A = 11 ...   % CPU time: 119.826 seconds
%@  % A = 12 ...   % CPU time: 154.304 seconds
%@  % A = 1 ...   % CPU time: 0.072 seconds
%@  % A = 2 ...   % CPU time: 0.318 seconds
%@  % A = 3 ...   % CPU time: 0.932 seconds
%@  % A = 4 ...   % CPU time: 2.203 seconds
%@  % A = 5 ...   % CPU time: 4.155 seconds
%@  % A = 6 ...   % CPU time: 7.499 seconds
%@  % A = 7 ...   % CPU time: 12.519 seconds
%@  % A = 8 ...   % CPU time: 19.985 seconds
%@  % A = 9 ...   % CPU time: 30.496 seconds
%@  % A = 10 ...   % CPU time: 44.771 seconds
%@  % A = 11 ...   % CPU time: 62.799 seconds
%@  % A = 12 ...   % CPU time: 87.063 seconds
%@ false.
