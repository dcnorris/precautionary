% Tallies T/N counting Toxicities per Number enrolled

:- module(tally, [
	      qcompare/4, % reified versions only should suffice
	      op(900, xfx, &=<),
	      (&=<)/3,
	      op(900, xfx, &>=),
	      (&>=)/3
	  ]).

:- use_module(library(clpz)).
:- use_module(library(pio)).
:- use_module(library(lists)).
:- use_module(library(dcgs)).
:- use_module(library(time)).
:- use_module(library(debug)).
:- use_module(library(dif)).
:- use_module(library(reif)).
:- use_module(library(format)).
:- use_module(library(lambda)).
:- use_module('/Users/david/Precis/precautionary/exec/prolog/inconceivable.pl').

%% The most fundamental relation between tallies is REACHABILITY,
%% the question of whether a possible path exists connecting them.
qcompare(~~, T1/N1, T2/N2) :- % REACHABILITY
    %% The following conditions translate as follows, under 3 scenarios:
    %% (=) If N1==N2, then we get T2 =< T1 =< T2 which holds iff T1==T2.
    %% (<) If N1 < N2, these conds translate to T1 =< T2 =< T1 + MaxTox.
    %% (>) If N1 > N2, these conds translate to T2 =< T1 =< T2 + MaxTox.
    T2 #=< T1 + max(0, N2 - N1),
    T1 #=< T2 + max(0, N1 - N2).

/*

This ~~ relation naturally gives us EQUIVALENCE CLASSES that we
can use to define a PARTIAL ORDERING on tallies that extends the
natural ordering between 2 tallies sharing a common denominator.
Specifically, for any 2 tallies, Q1 = T1/N1 and Q2 = T2/N2 with
N1 < N2 (we call Q1 the 'earlier' tally and Q2 the 'later' one),
we can project the earlier tally forward in time to a reachable
of tallies {Tr/N2 | Tr/N2 ~~ T1/N1}, and then compare that set
(in the obvious way) to Q2. If every element of the set bears
some relation to Q2, then we can say Q1 bears that relation
modulo reachability.

A graphical analysis of this relation is helpful. Here are the
relations generated by the tally 3/5, on the simplex of tallies
depicted as a grid:

  7  >  >  >  >  >  >  >  >  >  ≥

  6  >  >  >  >  >  >  >  >  ≥

  5  >  >  >  >  >  >  >  ≥

  4  >  >  >  >  >  >  ≥

  3  ≥  ≥  ≥  ≥  ≥  =  ≤  ≤  ≤  ≤

  2              ≤  <  <  <  <  <

  1           ≤  <  <  <  <  <  <

  0        ≤  <  <  <  <  <  <  <
 T
     0  1  2  3  4  5  6  7  8  9
    N

Note that nonexistent tallies (T/N with T>N) are included in the
relation, in order to emphasize the geometry, especially in the
'northwest' part of the figure, where imposing T≯N would wipe out
the ramp function formed by the (≥). Note how an (=)
is of course generated at 3/5, and how paired rays of (≤) and (≥)
emanate from 3/5, defining boundaries with interiors where the
corresponding *strict* relations hold. Note also that there are
two acute angles where neither relation holds. Thus, for example,
we cannot assert any relation between 2/3 and 3/5, because the
tallies reachable from 2/3 span the range 2/5--4/5, bracketed by
2/5 < 3/5 < 4/5. (Indeed, the reachability relation does hold,
so we could write 2/3 ~~ 3/5. But, as will become clear below,
it is the inequalities (≤) and (≥) that will provide the motive
force driving dose-escalation decisions. So reachability ~~ is
not emphasized in this figure.)

The geometry of this figure---and especially the CONVEXITY of the
obtuse-angle regions bounded by (≤) and (≥)---aids in understanding
the implementation of the qcompare/3 clauses below, and appreciating
properties of these relations, such as their transitivity.

*/

%% Note that, for reasons of performance, we express these relations
%% in terms of CLP(ℤ) constraints rather than by directly generating
%% the reachable sets.
%% TODO: Nevertheless, Prolog-based PROOFS via such representations
%%       might well have intrinsic interest.
%% Note also that we implement these comparisons on all of ℕ × ℕ, so that
%% queries about tallies must assert the simplex constraint themselves.
qcompare(=<, T1/N1, T2/N2) :-
    T1 + max(0, N2 - N1) #=< T2.

qcompare(<, T1/N1, T2/N2) :-
    T1 + max(0, N2 - N1) #< T2.

qcompare(>=, T1/N1, T2/N2) :-
    T1 #>= T2 + max(0, N1 - N2).

qcompare(>, T1/N1, T2/N2) :-
    T1 #> T2 + max(0, N1 - N2).

%% Reified versions of the above, as done at bottom of clpz.pl
qcompare(=<, T1/N1, T2/N2, Truth) :-
    %% Substitute direct comparisons for reified constraints when possible:
    (	ground(T1/N1 - T2/N2) ->
	(   zcompare(C, N2, N1),
	    (	C = (>),
		(   T1 + N2 - N1 #=< T2 -> Truth = true
		;   Truth = false
		)
	    ;	(C = (=) ; C = (<)),
		(   T1 #=< T2 -> Truth = true
		;   Truth = false
		)
	    )
	)
    ;	% general case (non-ground args 2 or 3) is handled by CLP(Z) ...
	T1 + max(0, N2 - N1) #=< T2 #<==> B,
	zo_t(B, Truth)
    ).

qcompare(<, T1/N1, T2/N2, Truth) :-
    T1 + max(0, N2 - N1) #< T2 #<==> B,
    zo_t(B, Truth).
	
qcompare(>=, Q1, Q2, Truth) :- qcompare(=<, Q2, Q1, Truth).

qcompare(>, T1/N1, T2/N2, Truth) :-
    T1 #> T2 + max(0, N1 - N2) #<==> B,
    zo_t(B, Truth).

zo_t(0, false).
zo_t(1, true).

%% Operators for the truly useful comparisons of BOIN:
:- op(900, xfx, &=<).
&=<(Q1, Q2) :-
    qcompare(=<, Q1, Q2).

&=<(Q1, Q2, Truth) :- % reified
    qcompare(=<, Q1, Q2, Truth).

:- op(900, xfx, &>=).
&>=(Q1, Q2) :-
    qcompare(>=, Q1, Q2).

&>=(Q1, Q2, Truth) :- % reified
    qcompare(>=, Q1, Q2, Truth).


%% Fairly enumerate tally pairs (Q1, Q2) pairs JOINTLY to avoid
%% repeating tests while 'sweeping' the space of cases to exclude
%% the 'inconceivable' systematically on increasing subsets of
%% the domain.
%% This is intended to be invoked with (Size in Min..Max), as e.g.
%% by inconceivable/3.
tally_pair(T1/N1, T2/N2, Size) :-
    Size #> 0,
    N1 #= Size, % NB: naive (N1 in 1..Size) would duplicate pairs
    N2 in 1..N1, indomain(N2),
    T1 in 0..N1,
    T2 in 0..N2,
    indomain(T1), indomain(T2).

%% TODO: Generalize tally_pair/3, tally_triple/4 to LISTS of tallies?
tally_triple(T1/N1, T2/N2, T3/N3, Size) :-
    tally_pair(T1/N1, T2/N2, Size),
    N3 in 1..N2, indomain(N3),
    T3 in 0..N3.

%% Demonstrate the TRANSITIVITY of (&=<) and (&>=)
violate_transitivity(C, Q1, Q2, Q3, Size) :-
    tally_triple(Q1, Q2, Q3, Size),
    qcompare(C, Q1, Q2),
    qcompare(C, Q2, Q3),
    %% At this point Q1 (C) Q2 (C) Q3 holds, and now we
    %% ask whether it's possible that Q1 (C) Q3 DOESN'T:
    qcompare(C, Q1, Q3, false). % reification to the rescue!

test :-
    (	format("Show that =< and >= hold simultaneously only in case of equivalence:~n", []),
	inconceivable((tally_pair(Q1, Q2, MaxN),
		       qcompare(>=, Q1, Q2),
		       qcompare(=<, Q1, Q2),
		       dif(Q1, Q2)),
		      MaxN, 1..12)
    ;	format("Demonstrate that strict inequalities are exclusive of ~~ ...~n", []),
	inconceivable((tally_pair(Q1, Q2, MaxN),
		       qcompare(>, Q1, Q2),
		       qcompare(~~, Q1, Q2)),
		      MaxN, 1..12)
    ;	inconceivable((tally_pair(Q1, Q2, MaxN),
		       qcompare(<, Q1, Q2),
		       qcompare(~~, Q1, Q2)),
		      MaxN, 1..12)
    ;	format("Show that =< and >= hold simultaneously only in case of equivalence:~n", []),
	inconceivable((tally_pair(Q1, Q2, MaxN),
		       qcompare(>=, Q1, Q2),
		       qcompare(=<, Q1, Q2),
		       dif(Q1, Q2)),
		      MaxN, 1..12)
    ;	format("Demonstrate transitivity of =< and >= ...~n", []),
	inconceivable(violate_transitivity(>=, Q1, Q2, Q3, Size), Size, 1..12)
    ;	inconceivable(violate_transitivity(=<, Q1, Q2, Q3, Size), Size, 1..12)
    ).

