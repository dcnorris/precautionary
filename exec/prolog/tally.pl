% Tallies T/N counting Toxicities per Number enrolled

:- module(tally, [
	      qcompare/4, % reified versions only should suffice
	      op(900, xfx, &=<),
	      (&=<)/3,
	      op(900, xfx, &>=),
	      (&>=)/3
	  ]).

:- use_module(library(clpz)).
:- use_module(library(pio)).
:- use_module(library(lists)).
:- use_module(library(dcgs)).
:- use_module(library(time)).
:- use_module(library(debug)).
:- use_module(library(dif)).
:- use_module(library(reif)).
:- use_module(library(format)).
:- use_module(library(lambda)).
:- use_module('/Users/david/Precis/precautionary/exec/prolog/inconceivable.pl').

%% The most fundamental relation between tallies is REACHABILITY,
%% the question of whether a possible path exists connecting them.
qcompare(~~, T1/N1, T2/N2) :- % REACHABILITY
    %% The following conditions translate as follows, under 3 scenarios:
    %% (=) If N1==N2, then we get T2 =< T1 =< T2 which holds iff T1==T2.
    %% (<) If N1 < N2, these conds translate to T1 =< T2 =< T1 + MaxTox.
    %% (>) If N1 > N2, these conds translate to T2 =< T1 =< T2 + MaxTox.
    T2 #=< T1 + max(0, N2 - N1),
    T1 #=< T2 + max(0, N1 - N2).

/*

This ~~ relation naturally gives us EQUIVALENCE CLASSES that we
can use to define a PARTIAL ORDERING on tallies that extends the
natural ordering between 2 tallies sharing a common denominator.
Specifically, for any 2 tallies, Q1 = T1/N1 and Q2 = T2/N2 with
N1 < N2 (we call Q1 the 'earlier' tally and Q2 the 'later' one),
we can project the earlier tally forward in time to a reachable
of tallies {Tr/N2 | Tr/N2 ~~ T1/N1}, and then compare that set
(in the obvious way) to Q2. If every element of the set bears
some relation to Q2, then we can say Q1 bears that relation
modulo reachability.

A graphical analysis of this relation is helpful. Here are the
relations generated by the tally 3/5, on the simplex of tallies
depicted as a grid:

  7  >  >  >  >  >  >  >  >  >  ≥

  6  >  >  >  >  >  >  >  >  ≥

  5  >  >  >  >  >  >  >  ≥

  4  >  >  >  >  >  >  ≥

  3  ≥  ≥  ≥  ≥  ≥  =  ≤  ≤  ≤  ≤

  2              ≤  <  <  <  <  <

  1           ≤  <  <  <  <  <  <

  0        ≤  <  <  <  <  <  <  <
 T
     0  1  2  3  4  5  6  7  8  9
    N

Note that nonexistent tallies (T/N with T>N) are included in the
relation, in order to emphasize the geometry, especially in the
'northwest' part of the figure, where imposing T≯N would wipe out
the ramp function formed by the (≥). Note how an (=)
is of course generated at 3/5, and how paired rays of (≤) and (≥)
emanate from 3/5, defining boundaries with interiors where the
corresponding *strict* relations hold. Note also that there are
two acute angles where neither relation holds. Thus, for example,
we cannot assert any relation between 2/3 and 3/5, because the
tallies reachable from 2/3 span the range 2/5--4/5, bracketed by
2/5 < 3/5 < 4/5. (Indeed, the reachability relation does hold,
so we could write 2/3 ~~ 3/5. But, as will become clear below,
it is the inequalities (≤) and (≥) that will provide the motive
force driving dose-escalation decisions. So reachability ~~ is
not emphasized in this figure.)

The geometry of this figure---and especially the CONVEXITY of the
obtuse-angle regions bounded by (≤) and (≥)---aids in understanding
the implementation of the qcompare/3 clauses below, and appreciating
properties of these relations, such as their transitivity.

*/

%% Note that, for reasons of performance, we express these relations
%% in terms of CLP(ℤ) constraints rather than by directly generating
%% the reachable sets.
%% TODO: Nevertheless, Prolog-based PROOFS via such representations
%%       might well have intrinsic interest.
%% Note also that we implement these comparisons on all of ℕ × ℕ, so that
%% queries about tallies must assert the simplex constraint themselves.
qcompare(=<, T1/N1, T2/N2) :-
    T1 + max(0, N2 - N1) #=< T2.

qcompare(<, T1/N1, T2/N2) :-
    T1 + max(0, N2 - N1) #< T2.

qcompare(>=, T1/N1, T2/N2) :-
    T1 #>= T2 + max(0, N1 - N2).

qcompare(>, T1/N1, T2/N2) :-
    T1 #> T2 + max(0, N1 - N2).

%% Reified versions of the above, as done at bottom of clpz.pl
qcompare(=<, T1/N1, T2/N2, Truth) :-
    %% Let's try using fast arithmetic, when possible
    (	ground(T1/N1 - T2/N2) ->
	(   DN #= N2 - N1,
	    zcompare(C, DN, 0), % TODO: May be clearer to do zcompare(C, N1, N2).
	    (	C = (>) ->
		(   T1plusDN #= T1 + DN,
		    T1plusDN #=< T2 -> Truth = true
		;   Truth = false
		)
	    ;	% DN =< 0, so a simpler condition applies
		(   T1 #=< T2 -> Truth = true
		;   Truth = false
		)
	    )
	)
    ;	% general case (non-ground args 2 or 3) is handled by CLP(Z) ...
	T1 + max(0, N2 - N1) #=< T2 #<==> B,
	zo_t(B, Truth)
    ).

qcompare(<, T1/N1, T2/N2, Truth) :-
    T1 + max(0, N2 - N1) #< T2 #<==> B,
    zo_t(B, Truth).
	
qcompare(>=, Q1, Q2, Truth) :- qcompare(=<, Q2, Q1, Truth).

qcompare(>, T1/N1, T2/N2, Truth) :-
    T1 #> T2 + max(0, N1 - N2) #<==> B,
    zo_t(B, Truth).

zo_t(0, false).
zo_t(1, true).

%% Operators for the truly useful comparisons of BOIN:
:- op(900, xfx, &=<).
&=<(Q1, Q2) :-
    qcompare(=<, Q1, Q2).

&=<(Q1, Q2, Truth) :- % reified
    qcompare(=<, Q1, Q2, Truth).

:- op(900, xfx, &>=).
&>=(Q1, Q2) :-
    qcompare(>=, Q1, Q2).

&>=(Q1, Q2, Truth) :- % reified
    qcompare(>=, Q1, Q2, Truth).


%% Fairly enumerate tally pairs (Q1, Q2) pairs JOINTLY to avoid
%% repeating tests while 'sweeping' the space of cases to exclude
%% the 'inconceivable' systematically on increasing subsets of
%% the domain.
%% This is intended to be invoked with (Size in Min..Max), as e.g.
%% by inconceivable/3.
tally_pair(T1/N1, T2/N2, Size) :-
    Size #> 0,
    N1 #= Size, % NB: naive (N1 in 1..Size) would duplicate pairs
    N2 in 1..N1, indomain(N2),
    T1 in 0..N1,
    T2 in 0..N2,
    indomain(T1), indomain(T2).


%% Demonstrate that strict inequalities are exclusive of ~~
%?- inconceivable((tally_pair(Q1, Q2, MaxN), qcompare(>, Q1, Q2), qcompare(~~, Q1, Q2)), MaxN, 1..12).
%@  % A = 1 ...   % CPU time: 0.024 seconds
%@  % A = 2 ...   % CPU time: 0.066 seconds
%@  % A = 3 ...   % CPU time: 0.141 seconds
%@  % A = 4 ...   % CPU time: 0.231 seconds
%@  % A = 5 ...   % CPU time: 0.379 seconds
%@  % A = 6 ...   % CPU time: 0.554 seconds
%@  % A = 7 ...   % CPU time: 0.786 seconds
%@  % A = 8 ...   % CPU time: 1.072 seconds
%@  % A = 9 ...   % CPU time: 1.456 seconds
%@  % A = 10 ...   % CPU time: 1.888 seconds
%@  % A = 11 ...   % CPU time: 2.399 seconds
%@  % A = 12 ...   % CPU time: 2.983 seconds
%@ false.

%?- inconceivable((tally_pair(Q1, Q2, MaxN), qcompare(<, Q1, Q2), qcompare(~~, Q1, Q2)), MaxN, 1..12).
%@  % A = 1 ...   % CPU time: 0.022 seconds
%@  % A = 2 ...   % CPU time: 0.064 seconds
%@  % A = 3 ...   % CPU time: 0.133 seconds
%@  % A = 4 ...   % CPU time: 0.231 seconds
%@  % A = 5 ...   % CPU time: 0.368 seconds
%@  % A = 6 ...   % CPU time: 0.549 seconds
%@  % A = 7 ...   % CPU time: 0.787 seconds
%@  % A = 8 ...   % CPU time: 1.076 seconds
%@  % A = 9 ...   % CPU time: 1.437 seconds
%@  % A = 10 ...   % CPU time: 1.884 seconds
%@  % A = 11 ...   % CPU time: 2.384 seconds
%@  % A = 12 ...   % CPU time: 2.996 seconds
%@ false.

%% Show that =< and >= hold simultaneously only in case of equivalence:
%?- inconceivable((tally_pair(Q1, Q2, MaxN), qcompare(>=, Q1, Q2), qcompare(=<, Q1, Q2), dif(Q1, Q2)), MaxN, 1..12).
%@  % A = 1 ...   % CPU time: 0.026 seconds
%@  % A = 2 ...   % CPU time: 0.069 seconds
%@  % A = 3 ...   % CPU time: 0.130 seconds
%@  % A = 4 ...   % CPU time: 0.226 seconds
%@  % A = 5 ...   % CPU time: 0.372 seconds
%@  % A = 6 ...   % CPU time: 0.535 seconds
%@  % A = 7 ...   % CPU time: 0.767 seconds
%@  % A = 8 ...   % CPU time: 1.064 seconds
%@  % A = 9 ...   % CPU time: 1.407 seconds
%@  % A = 10 ...   % CPU time: 1.831 seconds
%@  % A = 11 ...   % CPU time: 2.299 seconds
%@  % A = 12 ...   % CPU time: 2.919 seconds
%@ false.

%% TODO: Generalize tally_pair/3, tally_triple/4 to LISTS of tallies?
tally_triple(T1/N1, T2/N2, T3/N3, Size) :-
    tally_pair(T1/N1, T2/N2, Size),
    N3 in 1..N2, indomain(N3),
    T3 in 0..N3.

%% Demonstrate the TRANSITIVITY of (&=<) and (&>=)
violate_transitivity(C, Q1, Q2, Q3, Size) :-
    tally_triple(Q1, Q2, Q3, Size),
    qcompare(C, Q1, Q2),
    qcompare(C, Q2, Q3),
    %% At this point Q1 (C) Q2 (C) Q3 holds, and now we
    %% ask whether it's possible that Q1 (C) Q3 DOESN'T:
    qcompare(C, Q1, Q3, false). % reification to the rescue!

%?- inconceivable(violate_transitivity(>=, Q1, Q2, Q3, Size), Size, 1..12).
%@  % A = 1 ...   % CPU time: 0.125 seconds
%@  % A = 2 ...   % CPU time: 0.591 seconds
%@  % A = 3 ...   % CPU time: 1.642 seconds
%@  % A = 4 ...   % CPU time: 3.755 seconds
%@  % A = 5 ...   % CPU time: 7.341 seconds
%@  % A = 6 ...   % CPU time: 13.139 seconds
%@  % A = 7 ...   % CPU time: 21.844 seconds
%@  % A = 8 ...   % CPU time: 33.834 seconds
%@  % A = 9 ...   % CPU time: 50.710 seconds
%@  % A = 10 ...   % CPU time: 73.905 seconds
%@  % A = 11 ...   % CPU time: 109.859 seconds
%@  % A = 12 ...   % CPU time: 143.716 seconds
%@ false.

%?- inconceivable(violate_transitivity(=<, Q1, Q2, Q3, Size), Size, 1..12).
%@  % A = 1 ...   % CPU time: 0.073 seconds
%@  % A = 2 ...   % CPU time: 0.337 seconds
%@  % A = 3 ...   % CPU time: 0.945 seconds
%@  % A = 4 ...   % CPU time: 2.128 seconds
%@  % A = 5 ...   % CPU time: 4.236 seconds
%@  % A = 6 ...   % CPU time: 7.433 seconds
%@  % A = 7 ...   % CPU time: 12.438 seconds
%@  % A = 8 ...   % CPU time: 19.504 seconds
%@  % A = 9 ...   % CPU time: 28.609 seconds
%@  % A = 10 ...   % CPU time: 41.008 seconds
%@  % A = 11 ...   % CPU time: 57.192 seconds
%@  % A = 12 ...   % CPU time: 83.729 seconds
%@ false.

